/** * @ClassName RateLimiter * @Description 令桶牌算法 * @Version 1.0 */package myproject.common.utils;import lombok.extern.slf4j.Slf4j;import myproject.common.exception.ServerException;import java.util.Date;import java.util.concurrent.*;import java.util.concurrent.atomic.AtomicInteger;@Slf4jpublic class RateLimiter {	private final int capacity; // 仓库容量	private final AtomicInteger tokens; // 当前剩余token数量	private final int refillRate; // 每秒补充token数	/**	 * @return	 * @title: RateLimiter	 * @Description //初始化令牌桶	 * @Param [capacity 仓库容量, refillRate 每秒补充token数]	 **/	public RateLimiter(int capacity, int refillRate) {		this.capacity = capacity;		this.tokens = new AtomicInteger(capacity);		this.refillRate = refillRate;		ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);		// 每隔 (1000 / refillRate) 毫秒补充一个令牌		scheduler.scheduleAtFixedRate(() -> {			if (tokens.get() < capacity) {				tokens.incrementAndGet();			}		}, 0, 1000 / refillRate, TimeUnit.MILLISECONDS);	}	// 从令牌桶中消耗一个令牌	public synchronized boolean tryConsume() {		if (tokens.get() > 0) {			tokens.decrementAndGet();			return true;		}		throw new ServerException("当前请求过多,限流了!!,请稍后重试!!!!");	}	/**	 * @return void	 * @title: main	 * @Description //测试限流	 * @Param [args]	 **/	public static void main(String[] args) throws InterruptedException {		RateLimiter tokenBucket = new RateLimiter(5, 2);		ExecutorService threadPool = Executors.newFixedThreadPool(10);		ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);		// 每隔1s钟，再发起三个请求， 按照令牌桶的策略，之后的每秒，每次三个请求，都会被接收2个		scheduler.scheduleAtFixedRate(() -> {			CountDownLatch countDownLatch = new CountDownLatch(3);			System.out.println("--------------------------start-------------------------------------->");			for (int i = 0; i < 3; i++) {				threadPool.execute(() -> {					System.out.println(new Date() + "Request " + Thread.currentThread().getId() + ": " + (tokenBucket.tryConsume() ? "Accepted" :							"Rejected"));					countDownLatch.countDown();				});			}			System.out.println("--------------------------end-------------------------------------->");			try {				countDownLatch.await();			} catch (InterruptedException e) {				e.printStackTrace();			}		}, 0, 1000, TimeUnit.MILLISECONDS);	}}