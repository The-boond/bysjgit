package myproject.common.utils;import cn.hutool.core.util.NumberUtil;import cn.hutool.core.util.StrUtil;import okhttp3.OkHttpClient;import org.json.JSONObject;import org.springframework.stereotype.Component;import javax.imageio.ImageIO;import java.awt.*;import java.awt.image.BufferedImage;import java.io.BufferedReader;import java.io.File;import java.io.IOException;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import java.nio.file.Files;import java.nio.file.Paths;import java.util.List;import java.util.*;import java.util.stream.Collectors;import java.util.stream.IntStream;@Componentpublic class FaceCatchUtils {	/**	 * 可选值为：1,2,4,8,16,32	 * 当值为64时会抛出异常，此时需要实现64位转10进制	 * radix 64 greater than Character.MAX_RADIX	 */	public static int compareLevel = 7;	public static Boolean isSimilar(String pic1Path, String pic2Path) throws IOException {		pic1Path = StrUtil.sub(pic1Path, pic1Path.indexOf("upload"), pic1Path.length());		pic2Path = StrUtil.sub(pic2Path, pic2Path.indexOf("upload"), pic2Path.length());		final List<Double> origin = getPicArrayData(pic1Path);		final List<Double> after = getPicArrayData(pic2Path);		Double pearsonBydim = getPearsonBydim(origin, after);		return !(NumberUtil.compare(pearsonBydim, getCompareThreshold()) < 0);	}	public static Double getCompareThreshold() {		return 0.7;	}	public static List<Double> getPicArrayData(String path) throws IOException {		BufferedImage image = ImageIO.read(Files.newInputStream(Paths.get(path)));		//初始化集合		final List<Double> picFingerprint = new ArrayList<>(compareLevel * compareLevel * compareLevel);		IntStream.range(0, compareLevel * compareLevel * compareLevel).forEach(i -> {			picFingerprint.add(i, 0.0);		});		//遍历像素点		for (int i = 0; i < image.getWidth(); i++) {			for (int j = 0; j < image.getHeight(); j++) {				Color color = new Color(image.getRGB(i, j));				//对像素点进行计算				putIntoFingerprintList(picFingerprint, color.getRed(), color.getGreen(), color.getBlue());			}		}		return picFingerprint;	}	/**	 * 放入像素的三原色进行计算，得到List的位置	 *	 * @param picFingerprintList picFingerprintList	 * @param r                  r	 * @param g                  g	 * @param b                  b	 * @return	 */	public static List<Double> putIntoFingerprintList(List<Double> picFingerprintList, int r, int g, int b) {		//比如r g b是126, 153, 200 且 compareLevel为16进制，得到字符串：79c ,然后转10进制，这个数字就是List的位置		final Integer index = Integer.valueOf(getBlockLocation(r) + getBlockLocation(g) + getBlockLocation(b), compareLevel);		final Double origin = picFingerprintList.get(index);		picFingerprintList.set(index, origin + 1);		return picFingerprintList;	}	/**	 * w	 * 计算 当前原色应该分在哪个区块	 *	 * @param colorPoint colorPoint	 * @return	 */	public static String getBlockLocation(int colorPoint) {		Optional<String> first = IntStream.range(0, compareLevel)				//以10进制计算分在哪个区块				.filter(i -> {					int areaStart = (256 / compareLevel) * i;					int areaEnd = (256 / compareLevel) * (i + 1) - 1;					return colorPoint >= areaStart && colorPoint <= areaEnd;				})				//如果compareLevel大于10则转为对应的进制的字符串				.mapToObj(location -> compareLevel > 10 ? Integer.toString(location, compareLevel) : location + "")				.findFirst();		return first.get();	}	public static void putIntoFingerprintMap(Map<Integer, Integer> picFingerprintMap, int r, int g, int b) {		final Integer picFingerprint = Integer.valueOf(getBlockLocation(r) + getBlockLocation(g) + getBlockLocation(b), compareLevel);		Integer value = picFingerprintMap.containsKey(picFingerprint) ? picFingerprintMap.get(picFingerprint) + 1 : 1;		picFingerprintMap.put(picFingerprint, value);	}	public static List<Double> getPicArrayDataByMap(String path) throws IOException {		BufferedImage bimg = ImageIO.read(new File(path));		final Map<Integer, Integer> picFingerprintMap = new HashMap<>();		for (int i = 0; i < bimg.getWidth(); i++) {			for (int j = 0; j < bimg.getHeight(); j++) {				//输出一列数据比对				Color color = new Color(bimg.getRGB(i, j));				int r = color.getRed();				int g = color.getGreen();				int b = color.getBlue();				putIntoFingerprintMap(picFingerprintMap, r, g, b);			}		}		final List<Integer> keys = picFingerprintMap.keySet().stream().sorted().collect(Collectors.toList());		final ArrayList<Double> picFingerprintList = new ArrayList<>(keys.size());		keys.forEach(key -> {			picFingerprintList.add(Double.valueOf(picFingerprintMap.get(key)));		});		return picFingerprintList;	}	public static Double getPearsonBydim(List<Double> ratingOne, List<Double> ratingTwo) {		try {			if (ratingOne.size() != ratingTwo.size()) {//两个变量的观测值是成对的，每对观测值之间相互独立。				if (ratingOne.size() > ratingTwo.size()) {//保留小的处理大					List<Double> temp = ratingOne;					ratingOne = new ArrayList<>();					for (int i = 0; i < ratingTwo.size(); i++) {						ratingOne.add(temp.get(i));					}				} else {					List<Double> temp = ratingTwo;					ratingTwo = new ArrayList<>();					for (int i = 0; i < ratingOne.size(); i++) {						ratingTwo.add(temp.get(i));					}				}			}			double sim = 0D;//最后的皮尔逊相关度系数			double commonItemsLen = ratingOne.size();//操作数的个数			double oneSum = 0D;//第一个相关数的和			double twoSum = 0D;//第二个相关数的和			double oneSqSum = 0D;//第一个相关数的平方和			double twoSqSum = 0D;//第二个相关数的平方和			double oneTwoSum = 0D;//两个相关数的乘积和			for (int i = 0; i < ratingOne.size(); i++) {//计算				double oneTemp = ratingOne.get(i);				double twoTemp = ratingTwo.get(i);				//求和				oneSum += oneTemp;				twoSum += twoTemp;				oneSqSum += Math.pow(oneTemp, 2);				twoSqSum += Math.pow(twoTemp, 2);				oneTwoSum += oneTemp * twoTemp;			}			double num = (commonItemsLen * oneTwoSum) - (oneSum * twoSum);			double den = Math.sqrt((commonItemsLen * oneSqSum - Math.pow(oneSum, 2)) * (commonItemsLen * twoSqSum - Math.pow(twoSum, 2)));			sim = (den == 0) ? 1 : num / den;			return sim;		} catch (Exception e) {			return null;		}	}	public static double getPearsonCorrelationScore(List<Double> x, List<Double> y) {		if (x.size() != y.size())			throw new RuntimeException("数据不正确！");		double[] xData = new double[x.size()];		double[] yData = new double[x.size()];		for (int i = 0; i < x.size(); i++) {			xData[i] = x.get(i);			yData[i] = y.get(i);		}		return getPearsonCorrelationScore(xData, yData);	}	public static double getPearsonCorrelationScore(double[] xData, double[] yData) {		if (xData.length != yData.length)			throw new RuntimeException("数据不正确！");		double xMeans;		double yMeans;		double numerator = 0;// 求解皮尔逊的分子		double denominator = 0;// 求解皮尔逊系数的分母		double result = 0;		// 拿到两个数据的平均值		xMeans = getMeans(xData);		yMeans = getMeans(yData);		// 计算皮尔逊系数的分子		numerator = generateNumerator(xData, xMeans, yData, yMeans);		// 计算皮尔逊系数的分母		denominator = generateDenomiator(xData, xMeans, yData, yMeans);		// 计算皮尔逊系数		result = numerator / denominator;		return result;	}	/**	 * 计算分子	 *	 * @param xData	 * @param xMeans	 * @param yData	 * @param yMeans	 * @return	 */	private static double generateNumerator(double[] xData, double xMeans, double[] yData, double yMeans) {		double numerator = 0.0;		for (int i = 0; i < xData.length; i++) {			numerator += (xData[i] - xMeans) * (yData[i] - yMeans);		}		return numerator;	}	/**	 * 生成分母	 *	 * @param yMeans	 * @param yData	 * @param xMeans	 * @param xData	 * @return 分母	 */	private static double generateDenomiator(double[] xData, double xMeans, double[] yData, double yMeans) {		double xSum = 0.0;		for (int i = 0; i < xData.length; i++) {			xSum += (xData[i] - xMeans) * (xData[i] - xMeans);		}		double ySum = 0.0;		for (int i = 0; i < yData.length; i++) {			ySum += (yData[i] - yMeans) * (yData[i] - yMeans);		}		return Math.sqrt(xSum) * Math.sqrt(ySum);	}	/**	 * 根据给定的数据集进行平均值计算	 *	 * @param	 * @return 给定数据集的平均值	 */	private static double getMeans(double[] datas) {		double sum = 0.0;		for (int i = 0; i < datas.length; i++) {			sum += datas[i];		}		return sum / datas.length;	}	public static final String API_KEY = "TRiEHddImTfGScfmBOkhhIQ6";	public static final String SECRET_KEY = "E4izTaR3L6Ak2ChxinI4bN4j810Zt89q";	static final OkHttpClient HTTP_CLIENT = new OkHttpClient().newBuilder().build();	public static String getAuth() {		// 官网获取的 API Key 更新为你注册的		// 官网获取的 Secret Key 更新为你注册的		return getAuth(API_KEY, SECRET_KEY);	}	/**	 * 获取API访问token	 * 该token有一定的有效期，需要自行管理，当失效时需重新获取.	 *	 * @param ak - 百度云官网获取的 API Key	 * @param sk - 百度云官网获取的 Securet Key	 * @return assess_token 示例：	 * "24.460da4889caad24cccdb1fea17221975.2592000.1491995545.282335-1234567"	 */	public static String getAuth(String ak, String sk) {		// 获取token地址		String authHost = "https://aip.baidubce.com/oauth/2.0/token?";		String getAccessTokenUrl = authHost				// 1. grant_type为固定参数				+ "grant_type=client_credentials"				// 2. 官网获取的 API Key				+ "&client_id=" + ak				// 3. 官网获取的 Secret Key				+ "&client_secret=" + sk;		try {			URL realUrl = new URL(getAccessTokenUrl);			// 打开和URL之间的连接			HttpURLConnection connection = (HttpURLConnection) realUrl.openConnection();			connection.setRequestMethod("GET");			connection.connect();			// 获取所有响应头字段			Map<String, List<String>> map = connection.getHeaderFields();			// 遍历所有的响应头字段			for (String key : map.keySet()) {				System.err.println(key + "--->" + map.get(key));			}			// 定义 BufferedReader输入流来读取URL的响应			BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));			String result = "";			String line;			while ((line = in.readLine()) != null) {				result += line;			}			/**			 * 返回结果示例			 */			System.err.println("result:" + result);			JSONObject jsonObject = new JSONObject(result);			String access_token = jsonObject.getString("access_token");			return access_token;		} catch (Exception e) {			System.err.print("获取token失败！");			e.printStackTrace(System.err);		}		return null;	}	public static Boolean isSimilar(String pic1Path, String pic2Path, Boolean usebaidu) throws IOException {		pic1Path = StrUtil.sub(pic1Path, pic1Path.indexOf("upload"), pic1Path.length());		pic2Path = StrUtil.sub(pic2Path, pic2Path.indexOf("upload"), pic2Path.length());		// 请求url		String url = "https://aip.baidubce.com/rest/2.0/face/v3/match";		try {			List<Map<String, Object>> images = new ArrayList<>();			byte[] bytes1 = FileUtil.readFileByBytes(pic1Path);			byte[] bytes2 = FileUtil.readFileByBytes(pic2Path);			String image1 = Base64Util.encode(bytes1);			String image2 = Base64Util.encode(bytes2);			Map<String, Object> map1 = new HashMap<>();			map1.put("image", image1);			map1.put("image_type", "BASE64");			map1.put("face_type", "LIVE");			map1.put("quality_control", "LOW");			map1.put("liveness_control", "LOW");			Map<String, Object> map2 = new HashMap<>();			map2.put("image", image2);			map2.put("image_type", "BASE64");			map2.put("face_type", "LIVE");			map2.put("quality_control", "LOW");			map2.put("liveness_control", "LOW");			images.add(map1);			images.add(map2);			String param = JsonUtils.toJsonString(images);			// 注意这里仅为了简化编码每一次请求都去获取access_token，线上环境access_token有过期时间， 客户端可自行缓存，过期后重新获取。			String accessToken = getAuth();			String result = HttpUtil.post(url, accessToken, "application/json", param);			System.out.println(result);			JSONObject jsonObject = new JSONObject(result);			int errorCode = jsonObject.getInt("error_code");			if (0 == errorCode) {				double score = jsonObject.getJSONObject("result").getDouble("score");				return score >= 70;			} else {				return false;			}		} catch (Exception e) {			e.printStackTrace();		}		return null;	}}